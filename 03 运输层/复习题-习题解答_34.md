### 3.4

#### R9 在我们的 rdt 协议中，为什么要引入序号？

> 假设底层信道是会产生比特差错的不丢包信道，那么接收方收到的包可能已经被损坏，此时我们要求发送方重传分组，直到接收方接收到完整无损的包，于是产生如下 FSM。
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/r9.1.png)
> 
> 上面这幅图的接收发和发送方是无法正常工作的，因为没有考虑到 ACK 和 NAK 包也会损坏的可能性。
> 
> 解决 ACK 和 NAK 也会损坏的方案是：若发送方接收到损坏的确认分组，那么它重传上一个分组，这么做带来的困难之处在于，对于接收方来说，我无法确认我发送的确认报文是否完好无损地被发送方接收到，所以我无法确认发送方下一个发过来的分组是一个新分组还是一个重传的分组。针对该困难，对分组引入序号即可解决，转换到接收方的视角，此时我收到 0 分组，我发送了 ACK 确认分组，下一次我又收到了 0 分组，这说明我的 ACK 分组在传送途中损坏，此时我再次重传 ACK 分组。如果此时我收到 0 分组，我发送了 ACK 确认分组，下一次我收到 1 分组，这说明我的 ACK 分组已经被发送方正常接收，于是产生了如下图所示的 FSM。
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/r9.2.png)

#### R10 在我们的 rdt 协议中，为什么要引入定时器？

> 假设信道即会产生比特差错，也会丢包，那么此时我们的停等协议可能会永远卡死，而无法进入到下一个状态重传分组。卡死的困境可以被描述如下：发送方的分组丢失了，此时发送方等待接收方的确认信息，而接收方什么都没接收到，因此等待着发送方的分组到达，这便陷入了死锁。因此需要引入定时器来判定是否发生了丢包事件，于是产生了如下图所示的 FSM。
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/r10.1.png)

#### R11 假定发送方和接收方之间的往返时延是固定的并且为发送方所知。假设分组能够丢失的话，在协议 rdt 3.0 中，一个定时器仍是必需的吗？试解释之。

> 对，定时起仍然是必须的，往返时延固定并且为发送方所知的优势仅在于：此时可以肯定的说，分组的确丢失了，而不是分组只是经历了比较大的时延却仍然在链路上传输的误判情况。

#### R12 在配套网站上使用 Go-Back-N (回退 N 步) Java 小程序。
#### a. 让源发送 5 个分组，在这 5 个分组的任何一个到达目的地之前暂停该动画。然后毁掉第一个分组并继续该动画。试描述发生的情况。
#### b. 重复该实验，只是现在让第一个分组到达目的地并毁掉第一个确认。再次描述发生的情况。
#### c. 最后，尝试发送 6 个分组。发生了什么情况？

> [Go-Back-N interactive animation](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/go-back-n-protocol/index.html)
> 
> a.
> 
> 第一个分组丢失后，接收方不会缓存任何失序到达的正确分组，因为之前没有正确接收过任何分组，所以不会回传上一个正确接收分组的 ACK (因为没有)。如果之前有正确接收过分组，那么会给每个失序到达的正确报文回传一个 ACK，ACK 的编号是之前正确接收过的分组的编号，接收方同样不缓存任何失序分组。发送方没有接收到对应 ACK 的确认，因此会产生超时事件，重发滑动窗口中所有已发送但未确认的分组。 
> 
> b.
> 
> 对第一个分组的确认报文丢失不会引起任何重传，因为每个确认报文携带的序号会更新发送方的最早发送未确认序号，因此，当剩余 4 个确认报文被发送方接收到后，发送方的最早发送未确认序号被更新为 5，此时，滑动窗口中没有任何已发送但未确认的报文等待重传。
> 
> c.
> 
> 发不了，因为滑动窗口的长度是 5，一次只能发 5 个，等到滑动窗口中的 5 个分组都被接收方确认后才能发送第 6 个分组。

#### R13 重复复习题 R12，但是现在使用 Selective Repeat (选择重传) Java 小程序

> [Selective Repeat interative animation](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html)
> 
> a.
> 
> 第一个分组丢失后，剩下的分组都被接收方接收到，并逐一缓存，并且给发送方回传 4 个确认报文，每个都携带有被接收方缓存的分组的序号。发送方接收到这些确认分组后，滑动窗口不会移动，但因为发送方知道，失序但正确到达的分组都已经被缓存，所以当发送方的超时事件发生时，发送方仅仅会重传第一个丢失的分组。 
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/r13.1.png)
> 
> b.
> 
> 第一个分组的确认报文丢失后，此时，接收方因为五个分组都正常接收，所以接收方的滑动窗口向前移动，但是由于发送方并不知道它到底是发送的第一个分组在被接收方接收前丢失了呢？还是接收方正常接收到了该分组，但是回传的确认报文丢失了，所以发送方的滑动窗口不会移动，它仍然会等待超时事件发生，然后重传滑动窗口内未被确认的第一个分组。
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/r13.2.png)
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/r13.3.png)
> 
> c.
> 
> 发不了，因为滑动窗口的限制。

