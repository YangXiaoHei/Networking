### 3.5 

#### R14 是非判断题：
#### a. 主机 A 经过一条 TCP 连接向主机 B 发送一个大文件。假设主机 B 没有数据发往主机 A。因为主机 B 不能随数据捎带确认，所以主机 B 将不向主机 A 发送确认。
#### b. 在连接的整个过程中，TCP 的 rwnd 的长度决不会变化。
#### c. 假设主机 A 通过一条 TCP 连接向主机 B 发送一个大文件。主机 A 发送但未被确认的字节数不会超过接收缓存的大小。
#### d. 假设主机 A 通过一条 TCP 连接向主机 B 发送一个大文件。如果对于这条连接的一个报文段的序号为 m，则对于后继报文段的序号将必然是 m + 1。
#### e. TCP 报文段在它的首部中有一个 rwnd 字段。
#### f. 假定在一条 TCP 连接中最后的 SampleRTT 等于 1 秒，那么对于该连接的 TimeoutInterval 的当前值必定大于等于 1 秒。
#### g. 假设主机 A 通过一条 TCP 连接向主机 B 发送一个序号为 38 的 4 个字节的报文段。在这个相同的报文段中，确认号必定是 42。

> a.
> 
> ❌
> 
> 主机 B 会对主机 A 发送的每个分组单独发送一个确认报文，并在确认报文段的确认号域填写期望接收的下一字节序号。 
> 
> b.
> 
> ❌
> 
> rwnd 会一直变化，rwnd 的值从接收方回传给发送方，用来进行流量控制。
> 
> c.
> 
> ✅
> 
> 但更为准确的描述应该是，主机 A 发送但未被确认的字节数不会超过 B 接收窗口 rwnd 的大小，（rwnd = 接收缓存 - [LastByteRead - LastByteRecv]）
> 
> d.
> 
> ❌
> 
> 对于握手报文段，的确是 m + 1 ，但是对于携带数据的报文段，下一个序号是前一个报文段携带数据的首字节序号加上数据的长度。
> 
> e.
> 
> ✅ 
> 
> 就是接收窗口字段
> 
> f.
> 
> ❌
> 
> 该连接当前的 TimeoutInterval 是由上一次的 SampleRTT 和 DevRTT 计算出来的，或者是超时重传加倍出来的，和这次的 SmapleRTT = 1 没啥关系。
> 
> g.
> 
> ❌
> 
> 报文中的确认号和序号没半毛钱关系，确认号是期待接收到接收端的下一个字节的序号

#### R15 假设主机 A 通过一条 TCP 连接向主机 B 发送两个紧接着的 TCP 报文段。第一个报文段的序号为 90，第二个报文段的序号为 110。
#### a. 第一个报文段中有多少数据？
#### b. 假设第一个报文段丢失而第二个报文段到达主机 B。那么在主机 B 发往主机 A 的确认报文中，确认号应该是多少？

> a.
> 
> 第一个报文段中有 119 - 90 + 1 = 20 字节的序号
> 
> b.
> 
> TCP 是累积确认的，因此假如第一个报文段丢失，而第二个报文段到达主机 B，那么主机 B 发往主机 A 的确认报文中，确认号是 90。

#### R16 考虑在 3.5 节中讨论的 Telnet 的例子。用户键入字符 C 数秒之后，用户又键入字符 R。那么在用户键入字符 R 之后，总共发送了多少个报文段，这些报文段中的序号和确认号字段应该填入什么？

> 
>  3 个报文段，见下图
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/03%20运输层/images/r16.png)
