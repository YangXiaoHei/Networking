#### P34. 3.5.4 节中的变量 SendBase 和 3.5.5 节中的变量 LastByteRevd 之间有什么关系?

> SendBase 是发送方已发出但未被确认的最小序号，因此 SendBase - 1 就是发送方发出后被确认过的最大序号，由于此时可能还有 ACK 正在发往发送方，但还没有到达，此时接收方的窗口滑动提前于发送方，因此 `SendBase - 1 <= LastByteRecvd`

#### P35. 3.5.5 节中的变量 LastByteRcvd 和 3.5.4 节中的变量 y 之间有什么关系?

> y 是某时刻 t TCP 发送方收到的对序号 y 分组的确认，一旦 TCP 收到该确认，那么说明接收方正确接收了序号直到 y - 1 的所有的分组，若 y 是接收方正确接收到的最新分组，那么 y = LastByteRecvd，若还有 ACK 分组在发往发送方的途中，那么 y < LastByteRecvd，无论如何都有，y - 1 <= LastByteRecvd 

#### P36. 在 3.5.4 节中，我们看到 TCP 直到收到 3 个冗余 ACK 才执行快速重传。你对 TCP 设计者没有选择在收到对报文段的第一个冗余 ACK 之后就快速重传有何看法？

> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p36.png)

#### P37. 比较 GBN、SR 和 TCP（无延时的 ACK）。假设对所有 3 个协议的超时值足够长，使得 5 个连续的数据报文段及其对应的 ACK 能够分别由接收主机（主机 B）和发送主机（主机 A）收到（如果在信道中无丢失）。假设主机 A 向主机 B 发送 5 个数据报文段，并且第二个报文段（从 A 发送）丢失。最后，所有 5 个数据报文段已经被主机 B 正确接收。
#### a. 主机 A 总共发送了多少报文段和主机 B 总共发送了多少 ACK？它们的序号是什么？对所有 3 个协议回答这个问题。
#### b. 如果对所有 3 个协议超时值比 5 RTT 长得多，则哪个协议在最短的时间间隔中成功地交付所有 5 个数据报文段？

> a.
> 
> 对于 GBN 协议：
> 
> 第二个报文丢失后，接收方丢弃 3,4,5，回传的 ACK 序号分别为 1 1 1 1，第一轮 4 个 ACK。
> 
> 第二轮发送方重传 2, 3, 4, 5，接收方回传的 ACK 序号分别为 2 3 4 5，第二轮 4 个 ACK。
> 
> 因此 GBN 协议总共发送 8 个 ACK，9 个数据分组
> 
> 对于 SR 协议：
> 
> 第二个报文丢失后，接收方缓存 3, 4, 5，回传的 ACK 序号分别为 1 3 4 5，第一轮 4 个 ACK。
> 
> 第二轮发送方重传 2，接收方回传的 ACK 为 2，第二轮 1 个 ACK
> 
> 因此 SR 协议总共发送 5 个 ACK，5 个数据分组
> 
> 对于 TCP 协议：
> 
> 第二个报文丢失后，接收方缓存 3,4,5 回传的 ACK 序号分别为 2 2 2 2 (接收方期待接受的分组序号，而不是已经正确接收到的分组序号)，第一轮 4 个 ACK。
> 
> 第二轮发送方在接收到 3 个冗余 ACK 后进入快速重传，因此重传 2 分组，接收方在将缓存的分组和丢失的分组排序后，回传 ACK 6，因此第二轮 1 个 ACK。
> 
> 因此 TCP 协议总共发送 5 个 ACK，5 个数据分组
> 
> b.
> 
> TCP 协议最快，因为 GBN 和 SR 都在根据超时间隔傻等，哎呀这个 2 到底丢没丢呢，丢没丢啊？直到超时间隔流逝后才能确定，嗯，看来这家伙是丢了。但是 TCP 接收到 3 个冗余 ACK 后立刻进入快速重传，因此 TCP 最快。

#### P38. 在图 3-53 中的 TCP 描述中，阈值 ssthresh 的值在几个地方被设置为 ssthresh = cwnd / 2，并且当出现一个丢包事件时，ssthresh 的值被设置为窗口长度的一半。当出现丢包事件时发送方发送的速率大约等于每 RTT cwnd 个报文段吗？解释你的答案。如果你觉得不是，你能建议一种不同的方式，进行 ssthresh 设置吗？

> 发送方的发送速率总是大约等于 cwnd / RTT

#### P39. 考虑图 3-46b。如果 Yin' 增加超过了 R/2，Yout 能够增加超过 R/3 吗？试着解释之。现在考虑图 3-46c。假定一个分组从路由器到接收方平均发送两次的话，如果 Yin' 增加超过 R/2，Yout 能够增加超过 R/4 吗？试解释之。 

> Yin' 增加超过了 R/2，Yout 的增加也不能超过 R/3，原因如下：
> 
> 1、当 Yin' 为 R/2 时，由于路由器缓存有限而丢失分组，导致分组重传，大约每 3 个分组就有一个重传，因此接收方的吞吐量最多只有 R/3，因此当 Yin' 继续增加超过 R/2，势必造成更多丢包和重传，接收方的吞吐量反而会下降。
> 
> 2、链路的容量只有 R，因此发送方再如何增长速率，最多只能以 R/2 的速率将分组推上链路。
> 
> 由于发送方提前超时，导致每个排队时延过大的分组都被重复传输，每个分组被转发两次，那么接收方吞吐量变为 R/4，而发送速率再增加，甚至可能会让被超时重传了一次的分组被重传两次，因此不可能超过 R/4。

#### P40. 考虑图 3-58。假设 TCP Reno 是一个经历如上所示行为的协议，回答下列问题。在各种情况中，简要地论证你的回答。
#### a. 指出 TCP 慢启动运行时的时间间隔。
#### b. 指出 TCP 拥塞避免运行时的时间间隔。
#### c. 在第 16 个传输轮回之后，报文段的丢失是根据 3 个冗余 ACK 还是根据超时检测出来的？
#### d. 在第 22 个传输轮回之后，报文段的丢失是根据 3 个冗余 ACK 还是根据超时检测出来的？
#### e. 在第 1 个传输轮回里，ssthresh 的初始值被设置为多少？
#### f. 在第 18 个传输轮回里，ssthresh 的值被设置为多少?
#### g. 在第 24 个传输轮回里，ssthresh 的值设置为多少？
#### h. 在哪个传输轮回内发送第 70 个报文段？
#### i. 假定在第 26 个传输轮回后，通过收到 3 个冗余 ACK 检测出有分组丢失，拥塞的窗口长度和 ssthresh 的值应当是多少？
#### j. 假定使用 TCP Tahoe (而不是 TCP Reno)，并假定在第 16 个传输轮回收到 3 个冗余 ACK。在第 19 个传输轮回，ssthresh 和拥塞窗口长度是什么？
#### k. 再次假设使用 TCP Tahoe, 在第 22 个传输轮回有一个超时事件。从第 17 个传输轮回到第 22 个传输轮回（包括这两个传输轮回），一共发送了多少个分组？

![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p40.png)

> a.
> 
> TCP 在慢启动阶段 cwnd 按照指数增长，因此 [0, 6]、[23, 26]
> 
> b.
> 
> TCP 拥塞避免时拥塞窗口线性增长，因此 [6, 16]、[17, 22]
> 
> c.
> ⚠️⚠️⚠️
> 在第 16 个传输轮回之后，丢包是根据冗余 ACK 检测出来的，如果是超时检测出来的，那么拥塞窗口长度会变为 1
> 
> d.
> 
> 在第 22 个传输轮回之后，丢包是根据超时检测出来的，因为拥塞窗口长度下降为 1
> 
> e.
> 
> 在第 1 个传输轮回中，ssthresh 初始值被设置为 32，因为慢启动阶段在拥塞窗口长度达到 32 时开始进入拥塞避免。
> 
> f.
> 
> 在 18 个传输轮回中，ssthresh 的值被设置为拥塞窗口的一半，此时拥塞窗口为 42，因此 ssthresh 被设置为 21。
> 
> g.
> 
> 在第 24 个传输轮回里，ssthresh 的值被设置为拥塞窗口的一半，当时拥塞窗口为 28，因此 ssthresh 被设置为 14。
> 
> h.
> 
> 在第 7 个传输轮回中发送第 70 个报文。
> 
> i.
> 
> 假定在第 26 个传输轮回后，通过收到 3 个冗余 ACK 检测出有分组丢失，拥塞的窗口长度和 ssthresh 的值应当分别为：`ssthresh = 8 / 2 = 4 MSS，cwnd = ssthresh + 3 x MSS = 7 MSS`
> 
> j.
> 
> TCP Tahoe 没有快速重传，因此接收到 3 个冗余 ACK 的做法也是 ssthresh 变为拥塞窗口的一半，即 21，拥塞窗口变为 1 MSS
> 
> k.
> 
> ⚠️⚠️⚠️⚠️ 为什么第 22 轮是 21 个？
> 
> 再次假设使用 TCP Tahoe, 在第 22 个传输轮回有一个超时事件。从第 17 个传输轮回到第 22 个传输轮回 (包括这两个传输轮回), 16 轮回冗余 ACK, 因此 17 轮回 1，18 -> 2，19 -> 4，20 -> 8，21 -> 16，22 -> 21，因此总共是 1 + 2 + 4 + 8 + 16 + 21 = 52 个分组。

#### P41. 参考图 3-56, 该图描述了 TCP 的 AIMD 算法的收敛性。假设 TCP 不采用乘性减，而是采用按某一常量减小窗口。所得的 AIAD 算法将收敛于一种平等共享算法吗？使用类似于图 3-56 中的图来论证你的结论。

> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p41.png)
> 
> 我们可以看出，如果只采用某一常量减小窗口，那么 AIAD 只会在 A-B 这一段直线上晃悠，没法收敛到平等共享算法。

#### P42. 在 3.5.4 中，我们讨论了在发生超时事件后将超时间隔加倍。为什么除了这种加倍超时间隔机制外，TCP 还需要基于窗口的拥塞控制机制（如在 3.7 节中学习的那种机制呢）呢？

> 如果 TCP 是停等协议，那么发生超时事件后将超时间隔加倍就足够成为拥塞控制机制了，但 TCP 采用的是流水线机制，加倍某个包的重传超时间隔并不能阻止 TCP 把更多的包发到网络中，只要滑动窗口中还有可用的序号，TCP 就会不断的将分组注入流水线中，因此 TCP 仍然需要基于窗口的拥塞控制机制来让 TCP 不会在网络拥塞时继续向流水线中注入大量分组。

#### P43. 主机 A 通过一条 TCP 连接向主机 B 发送一个很大的文件。在这条连接上，不会出现任何分组丢失和定时器超时。主机 A 与因特网连接链路的传输速率表示为 R bps。假设主机 A 上的进程能够以 S bps 的速率向 TCP 套接字发送数据，其中 S = 10 x R。进一步假设 TCP 的接收缓存足够大，能够容纳整个文件，并且发送缓存只能容纳这个文件的百分之一。如何防止主机 A 上的进程连续地向 TCP 套接字以速率 S bps 传送数据呢？还是用 TCP 流量控制呢？还是用 TCP 拥塞控制呢？或者用其他措施？阐述其理由。

> 首先，由于接收方的接收缓存能容纳整个大文件，因此不会出现流量控制；并且因为在这条连接上不会出现任何分组丢失和定时器超时，因此拥塞控制机制不会遏制发送方的速率。最后，由于发送方的发送缓存会很快被填充满，因此一旦发送缓存被填充满，进程将无法继续以 S 速率向套接字发送数据，而是以 R 向套接字发送数据。

#### P44. 考虑从一台主机经一条没有丢包的 TCP 连接向另一台主机发送一个大文件。
#### a. 假定 TCP 不具有慢启动的 AIMD 进行拥塞控制。假设每当收到一批 ACK 时，cwnd 增加一个 MSS，并且假设往返时间大约恒定，cwnd 从 6MSS 增加到 12 MSS 要花费多长时间（假设没有丢包事件）？
#### b. 对于该连接，到时间 = 6RTT, 其平均吞吐量时多少？（根据 MSS 和 RTT）？

> a.
> 
> 7RTT
> 
> b.
> 
> 在第一个 RTT 内，发了 5 MSS 的分组，第二个 RTT 内，发了 6 MSS，所以总共是 5 + 6 + 7 + 8 + 9 + 10 = 45 MSS，所以平均吞吐量是 45 / 6 = 7.5 MSS/RTT

#### P45. 回想 TCP 吞吐量的宏观描述。在链接速率从 W/(2 x RTT) 变化到 W/RTT 的周期内，只丢失了一个分组（在该周期结束）。
#### a. 证明其丢包率（分组丢失的比率）等于：
	`L = 丢包率 = 1 / ( 3/8 x W^2 + 3/4 x W )`
#### b. 如果一条连接的丢包率为 L，使用上面的结果，则它的平均速率近似由下式给出：
	`平均速率 ~ 1.22 x MSS / (RTT x sqrt(L))`
> a.
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p45.a.jpg)
> 
> b.
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p45.b.jpg)
> 
> 由于 W 的单位是报文段的个数，如果最后平均速率是按字节计数，那么就再乘上每个报文段的大小 MSS 字节。

#### P46. 考虑仅有一条单一的 TCP (Reno) 连接使用一条 10 Mbps 的链路，且该链路没有缓存任何数据。假设这条链路是发送主机和接收主机之间的唯一拥塞链路。假定某 TCP 发送方向接收方有一个大文件要发送，而接收方的接收缓存比拥塞窗口要大得多。我们也做下列假设：每个 TCP 报文段长度为 1500 字节；该连接的双向传播时延是 150 ms；并且该 TCP 连接总是处于拥塞避免阶段，即忽略了慢启动。
#### a. 这条 TCP 连接能够取得的最大窗口长度（以报文段计）是多少？
#### b. 这条 TCP 连接的平均窗口长度（以报文段计）和平均吞吐量（以 bps 计）是多少？
#### c. 这条 TCP 连接从丢包恢复后，再次到达其最大窗口要经历多长时间？

>
> // TODO 没想通 ⚠️⚠️⚠️
> 
> 链路没有缓存任何数据对结果有啥影响？
>
> a.
> 
> 方法一：
> 
> 最大窗口也就是出现丢包前的窗口长度，如果发送速率超出了链路容量，那么分组可能会丢失，即` W x 1500 x 8 / 0.15 = 10^7 => W = 125 个`
> 
> 方法二：
> 
> 若分组的发送时间大于 RTT，那么出现判定为超时丢包。即传输时延大于分组时延
> 
> `L/R > 0.15 => L = 1500 x 10^3 bit，即 W = 1500 x 10^3 / (1500 x 8) = 125 个 `
>
> b.
> 
> 我们知道一条连接的平均吞吐量为 0.75 x W / RTT，于是平均窗口长度为 0.75 x W = 0.75 x 125 = 94 个
> 
> 平均吞吐量为 `94 x 1500 x 8 / 0.15 = 7.52 Mbps`
> 
> c.
> 
> 每经过一个 RTT, 窗口就会增长 MSS，因此总共需要增长 W/2 个 RTT 才能恢复，即` W/2 x 0.15 = 94/2 x 0.15 = 7.05 s`

#### P47. 考虑在前面习题中所描述的场景。假设 10 Mbps 链路能缓存有限个报文段。试论证为了使该链路总是忙于发送数据，我们将要选择缓存长度使其至少为发送方和接收方之间链路速率 C 与双向传播时延之积。

> // TODO ⚠️⚠️⚠️没想通

#### P48. 重复习题 46, 但用一条 10 Gbps 链路代替 10 Mbps 链路。注意到在对 c 部分的答案中，应当认识到在从丢包恢复后，拥塞窗口长度到达最大窗口长度将需要很长时间。给出解决该问题的基本思路。

> a.
> 
> `W x 1500 x 8 / 0.15 = 10^10 => W = 1500 x 10^6 / (1500 x 8) = 125000`
> 
> b.
> 
> `平均窗口长度为 0.75 x 125000 = 93750`
> 
> `平均吞吐量为 93750 x 1500 x 8 / 0.15 = 7.5 Gbps` 
> 
> c.
> 
> 每经历 RTT，拥塞窗口长度增加一个 MSS，因此总共需要经历 `W/2` 个 RTT，即 `125000 / 2 * 0.15 = 9375 s = 156 min` 
> 
> 解决恢复拥塞窗口的长时间的问题，可以让拥塞窗口在每个 RTT 后以更快的步长增加，比如 ScalableTCP 和 HighSpeed TCP。

#### P49. 令 T (用 RTT 度量)表示一条 TCP 连接将拥塞窗口从 W/2 增加到 W  所需的时间间隔，其中 W 是最大的拥塞窗口长度。论证 T 是 TCP 平均吞吐量的函数。

> TCP 的平均吞吐量是
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p49.1.png)
> 
> 因此得到丢包率为 
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p49.2.png)
> 
> 恢复到 W 所需时间为 
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p49.3.png)
> 
> 将 L 带入得到
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p49.4.png)

#### P50. 考虑一种简化的 TCP 的 AIMD 算法，其中拥塞窗口长度用报文段的数量来度量，而不是用字节度量。在加性增中，每个 RTT 拥塞窗口长度增加一个报文段。在乘性减中，拥塞窗口长度减小一半（如果结果不是一个整数，向下取整到最近的整数）。假设两条 TCP 连接 C1 和 C2，它们共享一条速率为每秒 30 个报文段的单一拥塞链路。假设 C1 和 C2 均处于拥塞避免阶段。连接 C1 的 RTT 是 50 ms，连接 C2 的 RTT 是 100 ms。假设当链路中的数据速率超过了链路的速率时，所有 TCP 连接经受数据报文段丢失。
#### a. 如果在时刻 t0，C1 和 C2 具有 10 个报文段的拥塞窗口，在 1000 ms 后它们的拥塞窗口为多长？
#### b. 经长时间运行，这两条连接将取得共享该链路的相同的带宽吗？

> a.
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p50.png)
> 
> 
> b.
> 
> 不会，C1 占用的带宽比 C2 多将近 3 倍，因为 C1 的 RTT 更小，所以 C1 将能更快地调整自己的滑动窗口，从上图中可以看出，在后期 C1 全部都能在每个 RTT 开始领先于 C2 调整滑动窗口，因此它能向上波动。

#### P51. 考虑在前面习题中描述的网络。现在假设两条 TCP 连接 C1 和 C2, 它们具有相同的 100 ms RTT。假设在时刻 t0, C1 的拥塞窗口长度为 15 个报文段，而 C2 的拥塞窗口长度是 10 个报文段。
#### a. 在 2200 ms 后，它们的拥塞窗口长度为多长？
#### b. 经长时间运行，这两条连接将取得共享该拥塞链路的相同的带宽吗？
#### c. 如果这两条连接在相同时间达到它们的最大窗口长度，并在相同时间达到它们的最小窗口长度，我们说这两条连接是同步的。经长时间运行，这两条连接将最终变得同步吗？如果是，它们的最大窗口长度是多少？
#### d. 这种同步将有助于改善共享链路的利用率吗？为什么？给出打破这种同步的某种思路。

> a.
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p51.png)
> 
> C1 和 C2 都在 10 ~ 20 的波动
> 
> b.
> 
> 能，因为该 TCP 采用 AIMD 算法并且具有相同的 RTT。
> 
> c.
> 
> 会变得同步，最大窗口长度是 2
> 
> d.
> 
> 不会有助于改善链路的利用率，因为速率在 20 ~ 40 之间波动，当路由器是有限缓存（为啥？⚠️⚠️⚠️）时，并且丢包是任意情况下，会打破该同步，因为她们将在不同的时间点改变窗口大小。

#### P52. 考虑修改 TCP 的拥塞控制算法。不使用加性增，使用乘性增。无论何时某 TCP 收到一个合法的 ACK, 就将其窗口长度增加一个小正数 a（0 < a < 1）。求出丢包率 L 和最大拥塞窗口 W 之间的函数关系。论证：对于这种修正的 TCP, 无论 TCP 的平均吞吐量如何，一条 TCP 连接将其拥塞窗口长度从 W/2 增加到 W, 总是需要相同的时间。

> 设 S 为窗口从 W/2 增加到 W 期间发送的总报文段数目，因此有
> 
> `S = W/2[ 1 + (1 + a) + (1 + a)^2 + ... + (1 + a)^k ] = W/2[((a + 1)^(k+1) - 1) / a]`
> 
> 由 `k = log(a+1, 2)` 得到
> 
> `S = W(2a + 1)/(2a)`
> 
> 由 `L = 1/S = 2a/(W(2a + 1))`
> 
> 窗口由 W/2 增加到 W 期间所经历的时间 T 为 `kRTT = log(a+1, 2)RTT`
> 
> 因此该 TCP 的平均吞吐量为 `S/T = 1/(kLRTT)` 以 MSS 为单位。

#### P53. 在 3.7 节对 TCP 未来的讨论中，我们注意到为了取得 10 Gbps 的吞吐量，TCP 仅能容忍 2 x 10^-10 的报文段丢失率（或等价为每 5 000 000 000 个报文段有一个丢包事件）。给出针对 3.7 节中给定的 RTT 和 MSS 值的对 2 x 10^10 值的推导。如果 TCP 需要支持一条 100 Gbps 的连接，所能容忍的丢包率是多少？

> 
> `平均吞吐量 = 1.22 x MSS / (RTT x sqrt(L)) = 10^10`
> 
> 假定 RTT 是 100 ms, 并且 MSS 是 1500 字节，那么 `sqrt(L) = 1.22 x 1500 x 8 / (0.1 x 10^10) = 0.00001464`
> 
> 则 `L = 0.00001464 x 0.00001464 = 0.0000000002`
> 
> 如果需要支持一条 100 Gbps 的连接，能容忍的丢包率是：
> 
> `sqrt(L) = 1.22 x MSS / (RTT x B) = 1.22 x 1500 x 8 / (0.1 x 10^11) = 0.000000000002`
> 
> 即每 5 千亿个包中有一个丢失

#### P54. 在 3.7 节中对 TCP 拥塞控制的讨论中，我们隐含地假定 TCP 发送方总是有数据要发送。现在考虑下列情况，某 TCP 发送方发送大量数据，然后在 t1 时刻变得空闲（因为它没有更多的数据要发送）。TCP 在相对长的时间内保持空闲，然后在 t2 时刻要发送更多的数据。当 TCP 在 t2 开始发送数据时，让它使用在 t1 时刻的 cwnd 和 ssthresh 值，将有什么样的优点和缺点？你建议使用什么样的方法？为什么？

> 优点：
> 
> 不需要重新经历慢启动就能达到 t1 时的拥塞窗口和吞吐量
> 
> 缺点：
> 
> 此方法使 TCP 的拥塞控制不再精确，特别是假如 t1 ~ t2 之间链路变得很拥塞，那么该方法将会雪上加霜的在不堪负重的链路中施加压力。

#### P56. 在这个习题中，我们考虑由 TCP 慢启动阶段引入的时延。考虑一个客户和一个 Web 服务器直接连接到速率为 R 的一条链路。假定该客户要取回一个对象，其长度正好等于 15 S，其中 S 是最大报文段长度(MSS)。客户和服务器之间的往返时间表示为 RTT（假设为常数）。忽略协议首部，确定在下列情况下取回该对象的时间（包括 TCP 连接创建）：
#### a. 4S/R > S/R + RTT > 2S/R
#### b. S/R + RTT > 4S/R
#### c. S/R > RTT

> a.
> 
> 对于 a 中的条件，变形后得到 `3S/R > RTT > S/R`
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p56.1.png)
> 
> b.
> 
> 对于 b 中的条件，变形后得到 `RTT > 3S/R`
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p56.2.png)
> 
> c.
> 
> 对于 c 中的条件，变形后得到 `S/R > RTT` 
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p56.3.png)
> 
