#### P6. 考虑我们改正协议 rdt 2.1 的动机。试说明如图 3-57 所示的接收方与如图 3-11 所示的发送方运行时，接收方可能会引起发送方和接收方进入死锁状态，即双方都在等待不可能发生的事件。

> ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/03%20运输层/images/p6.png)
> 
> 假设发送方发来分组 0，接收方正确接收到该分组 0，并给发送方回传 ACK 作为确认，但该 ACK 抵达发送方前损坏，于是发送方重传分组 0，当接收方正确接收到该分组 0 时，接收方处于 wait 1 状态，于是给发送方回传 NAK。此时进入死锁，无论发送方是否正确接收到该 NAK，都会重传分组 0，无论接收方是否正确接收该分组 0，都会回传 NAK。

#### P7. 在 rdt 3.0 协议中，从接收方向发送方流动的 ACK 分组没有序号（尽管它们具有 ACK 字段，该字段包括了它们正在确认的分组的序号）。为什么这些 ACK 分组不需要序号呢？

> 接收方需要分组序号是因为接收方无法确认自己的 ACK 能否正确到达发送方，因此无法确认发送方是重传分组还是新分组。但发送方并不需要辨认 ACK 是重传还是新的 ACK，只要是 ACK，发送方就会进入到下一个状态等待上层调用，冗余的 ACK 被忽略。

#### P8. 画出协议 rdt 3.0 接收方的 FSM。

> ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/03%20运输层/images/p8.png)

#### P9. 当数据分组和确认分组发生篡改时，给出 rdt 3.0 协议运行的轨迹。你画出的轨迹应当类似于图 3-16 中所用的图。

> ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/03%20运输层/images/p9.png)

#### P10. 考虑一个能够丢失分组但其最大时延已知的信道。修改协议 rdt 2.1 ，以包括发送方超时和重传机制。非正式地论证：为什么你的协议能够通过该信道正确通信？

> 原来的 rdt 2.1 如下图所示
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/03%20运输层/images/p10.1.png)
> 
> 添加了超时和重传机制的 rdt 2.1 如下图所示
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/03%20运输层/images/p10.2.png)
> 
> 为什么我的协议能够通过该信道正确通信？
> 
> 1、由于最大时延已知，所以我可以将定时器的超时事件设置为大于最大超时时延，于是发送方永远不会提前超时，所以发送方不会在 wait 0 或者 wait 1 状态接收到分组。
> 
> 2、对于接收方，若此时在等待分组 0 到达，因为发送方不会提前超时，所以在分组 0 到达后再来一个分组 0 只可能发生在发送方没有正确接收到 ACK 的情况下出现。此时只需重传 ACK。

#### P11. 考虑在图 3-14 中的 rdt 2.2 接收方，在状态 “等待来自下层的 0” 和状态 “等待来自下层的 1” 中的自转换（即从某状态转换回自身）中生成一个新分组：sndpk = make_pkt(ACK, 1, checksum) 和 sndpk = make_pkt(ACK, 0, checksum)。如果这个动作从状态 “等待来自下层的 1” 中的自转换中删除，该协议将正确工作吗？评估你的答案。在状态 ”等待来自下层的 0“ 中的自转换中删除这个事件将会怎样？【提示：在后一种情况下，考虑如果第一个发送方到达接收方的分组损坏的话，将会发生什么情况？】

> 这当然是无法正常工作的咯....若发送方发送了一个分组 0，但是这个包到达接收方时损坏了，此时 rdt 2.2 接收方没啥反应，而发送方在等一个 ACK 0 的确认，于是造成死锁。后一种情况也一样。

#### P12. rdt 3.0 协议的发送方直接忽略（即不采取任何动作）接收到的所有出现差错和确认分组的确认号（acknum）字段中的值有差错的分组。假设在这种情况下，rdt 3.0 只是重传当前的数据分组，该协议是否还能正常运行？（提示：考虑在下列情况下会发生什么情况：仅有一个比特差错时；报文没有丢失但能出现定时器过早超时。考虑到当 n 趋于无穷时，第 n 个分组将被发送多少次。）

> 该协议还能正常运行。
> 
> ⚠️⚠️⚠️ 没太想清楚
> 
> 若发送方接收到错包时就重传分组，那么如果接收方一直没有收到正确的包，发送方就会一直发，因此第 n 个分组将会被发送无数次。

#### P13. 考虑 rdt 3.0 协议。如果发送方和接收方网络能够对报文重排序（即在发送方和接收方之间的媒体上传播的两个报文段能重新排序），那么比特交替协议将不能正确工作（确信你清楚地理解这时它不能正确工作的原因），试画图说明之。画图时把发送方放在左边，接收方放在右边，使时间轴朝下，标出交换的数据报文（D）和确认报文（A）。要标明与任何数据和确认报文段相关的序号。

> ![](https://github.com/YangXiaoHei/Networking/blob/master/计算机网络自顶向下/03%20运输层/images/p13.png)

#### P14. 考虑一种仅使用否定确认的可靠数据传输协议。假定发送方只是偶尔发送数据。只用 NAK 的协议是否会比使用 ACK 的协议更好？为什么？现在我们假设发送方要发送大量的数据，并且该端到端连接很少丢包。在第二种情况下，只用 NAK 的协议是否会比使用 ACK 的协议更好？为什么？

> //TODO
> 
> ⚠️⚠️⚠️ 没想明白仅使用否定确认的可靠数据传输协议如何实现？？？
> 
> 在只采用否定确认的协议中，分组 x 的丢失只有当分组 x + 1 被接收方收到后才能发现，如果 x 和 x + 1 之间有很长的时延的话，那么分组 x 必须经历很长的时延才能被恢复。
> 
> 如果发送方要发送大量数据，并且很少丢包，那么仅使用 NAK 的协议更好，因为分组 x 的丢失能很快被恢复（因为发送方发包很频繁），并且减少了大量 ACK 的确认，而 NAK 只占很少的一部分（因为题目假设端到端很少丢包）

#### P15. 考虑如图 3.17 所示的跨国示例，当信道利用率要大于 98% 时窗口尺寸需要变多大？假定一个分组的尺寸是 1500 字节（包括首部字段和应用数据）。

> 假设 `R = 1 Gbps`，传播时延 `RTT = 30 ms`
> 
> 计算传输时延为 `T_trans = L / R = 1500 x 8 / 10^9 = 0.000012 s = 0.012 ms = 12 us`
> 
> 由 `U_sender = win_size / ( (RTT / (L/R) + 1 ) = 0.98` 得到：
> 
> `win_size = 2450.98 ~ 2450`

#### P16. 假设某应用使用 rdt 3.0 作为运输层协议。因为停等协议具有非常低的信道利用率（显示在网络跨越国家的例子中），该应用程序的设计者让接收方持续回送许多（大于2）交替的 ACK 0 和 ACK 1，即使对应的数据未到达接收方。这个应用程序设计将能增加信道利用率吗？为什么？该方法存在某种潜在的问题吗？试解释之。

> 能增加信道利用率。毕竟发送方接收到 0 或者 1 就会转出到 `rdt_send(data)` 状态发送分组。潜在的问题是：接收方并没有真正接收到很多分组，而这些提前透支的 ACK 0 或者 ACK 1 可能并不能正确接收到对应的分组。
