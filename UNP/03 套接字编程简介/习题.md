#### P1 为什么诸如此类套接字地址结构的长度之类的值-结果参数要用指针来传递？
   * 因为内核要修改该值以通知应用程序

#### P2 为什么 readn 和 writen 函数都将 void * 型指针转换为 char * 指针？
   * 因为 void * 指针没有类型，无法取值。
   
#### P3 `inet_aton` 和 `inet_addr` 函数对于接受什么作为点分十进制 IPv4 地址串一直相当随意：允许由小数点分隔的 1 ~ 4 个数，也允许由一个前导的 0x 来指定一个十六进制数，还允许由一个前导的 0 来指定的一个八进制数。`inet_pton` 函数对 IPv4 地址的要求却严格得多，明确要求用三个小数点来分隔四个在 0 ~ 255 之间的十进制数。当指定地址族协议为 `AF_INET6` 时，inet_pton 不允许指定点分十进制数地址，不过有人可能争辩说应该允许，返回值就是对应这个点分十进制串的 IPv4 映射的 IPv6 地址。
#### 试写一个名为 `inet_pton_loose` 的函数，它能处理如下情形: 如果地址族为 `AF_INET` 且 inet_pton 返回 0, 那就调用 `inet_aton` 看是否成功；类似地，如果地址族为 `AF_INET6` 且 `inet_pton` 返回 0，那就调用 `inet_aton` 看是否成功，若成功则返回其 IPv4 映射的 IPv6 地址。

  * [Practise_03.c](https://github.com/YangXiaoHei/Networking/blob/master/UNP/03%20套接字编程简介/progs/Practise_03.c)
  
  * 运行结果如下 :
  
  ~~~C
  ➜  progs git:(master) ✗ cc Practise_03.c tool/bin_tool.c && ./a.out
	10011101 11001111 00011101 01110111 11111111 11111111 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
  ~~~