#### P3. UDP 和 TCP 使用反码来计算它们的校验和。假设你有下面 3 个 8 比特字节：01010011，01100110，01110100。这些 8 比特字节和的反码是多少？（注意到尽管 UDP 和 TCP 使用 16 比特的字来计算校验和，但对于这个问题，你应该考虑 8 比特和。）写出所有工作过程。UDP 为什么要用该和的反码，即为什么不直接使用该和呢？使用该反码方案，接收方如何检测出差错？1 比特的差错将可能检测不出来吗？2 比特的差错呢？

> 第一问：这些 8 比特字节和的反码是多少？
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p3.1.png)
> 
> 答案： 1 1 0 1  0 0 0 1
> 
> 第二问：UDP 为什么要用该和的反码，为什么不直接使用该和呢？
> 
> 因为接收方的校验方式是把这原来的 3 个字节和 checksum 加在一块，看结果中是否有包含 0 比特位来判断是否出现差错。
> 
> 第三问：使用该反码方案，接收方如何检测出差错？
> 
> 若这 3 个字节和 checksum 加在一块的结果中包含 0 比特位，那么说明出现了比特位差错
> 
> ⚠️⚠️⚠️第四问：1 比特的差错将可能检测不出来吗？2 比特的差错呢？
> 
> 1 比特差错一定会被检测出来，但是 2 比特的差错不一定能被检测出来。比如 
> 
> 第一个字节 0101 0011 --> 0101 0010 
> 第二个字节 0110 0110 --> 0101 0111
> 
> 上面两个字节的最后一个比特位交换位置，这样的话，加和不会改变。所以 checksum 也不会发生改变。

#### P4. 
#### a. 假定你有下列 2 个字节：0101 1100 和 0110 0101。这两个字节之和的反码是什么？
#### b. 假定你有下列 2 个字节：1101 1010 和 0110 0101。这两个字节之和的反码是什么？
#### c. 对于（a）中的字节，给出一个例子，使得这两个字节中的每一个都在一个比特反转时，其反码不会改变。

> a.
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p4.1.png)
> 
> b.
> 
> ![](https://github.com/YangXiaoHei/Networking/blob/master/03%20运输层/images/p4.2.png)
> 
> c.
> 
> `0101 1100`
> 
> `0110 0101`
> 
> 交换两个字节的第 5 个比特位，变为
> 
> `0100 1100`
> 
> `0111 0101`
> 
> 这样加和不会变，自然反码也不会变

#### P5. 假定某 UDP 接收方对接收到的 UDP 报文段计算因特网校验和，并发现它与承载在校验和字段中的值相匹配。该接收方能够绝对确信没有出现过比特差错吗？试解释之。

> 不能，两个字节相加时，如果对应的比特位调换位置，加和并不会发生改变，比如 0001 和 0010 变为 0011 和 0000，加和都是 0011，如 P3 所说，一个比特位的差错可以被校验出来，但是两个比特位的差错不一定能被校验出来。
